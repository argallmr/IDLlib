; docformat = 'rst'
;
; NAME:
;       MrReformIndices
;
;*****************************************************************************************
;   Copyright (c) 2014, Matthew Argall                                                   ;
;   All rights reserved.                                                                 ;
;                                                                                        ;
;   Redistribution and use in source and binary forms, with or without modification,     ;
;   are permitted provided that the following conditions are met:                        ;
;                                                                                        ;
;       * Redistributions of source code must retain the above copyright notice,         ;
;         this list of conditions and the following disclaimer.                          ;
;       * Redistributions in binary form must reproduce the above copyright notice,      ;
;         this list of conditions and the following disclaimer in the documentation      ;
;         and/or other materials provided with the distribution.                         ;
;       * Neither the name of the <ORGANIZATION> nor the names of its contributors may   ;
;         be used to endorse or promote products derived from this software without      ;
;         specific prior written permission.                                             ;
;                                                                                        ;
;   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY  ;
;   EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES ;
;   OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT  ;
;   SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,       ;
;   INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED ;
;   TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR   ;
;   BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN     ;
;   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN   ;
;   ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH  ;
;   DAMAGE.                                                                              ;
;*****************************************************************************************
;
; PURPOSE
;+
;   The purpose of this function is to convert subscript ranges to a 1D array of
;   subscripts.
;
; :Examples:
;   See the main level program at the end of this routine::
;       IDL> .r MrReformIndices
;
;
;   Indices are generated by
;
;         index = Sum( (# elements dimension i-1) * (index in dimension i) )
;
;   and summing over each dimension i.
;
;   As an example, find the following 1D index of a 4x4x3x2 array::
;     IDL> arr = indgen(4,4,3,2)
;     IDL> print, arr[2,0,0,0]
;            2
;     IDL> print, arr[2,2,0,0]
;           10
;     IDL> print, arr[2,2,2,0]
;           42
;     IDL> print, arr[2,2,0,1]
;           58
;
;   To do so, note that::
;         dims = [ 4, 4, 3, 2]  <-- size(arr, /DIMENSIONS)
;         pDim = [ 4,16,48,96]  <-- product(dims, /PRODUCT, /INTEGER)
;
;   Now begin::
;         1. inds = [2,0,0,0]
;            result = inds[0] + inds[1]*pDims[0] + inds[2]*pDims[1] + inds[3]*pDims[2]
;            result = 48*0 + 16*0 + 4*0 + 2
;            result = 2
;
;         2. inds = [2,2,0,0]
;            result = inds[0] + inds[1]*pDims[0] + inds[2]*pDims[1] + inds[3]*pDims[2]
;            result = 48*0 + 16*0 + 4*2 + 2
;            result = 10
;
;         3. inds = [2,2,2,0]
;            result = inds[0] + inds[1]*pDims[0] + inds[2]*pDims[1] + inds[3]*pDims[2]
;            result = 48*0 + 16*2 + 4*2 + 2
;            result = 42
;
;         4. inds = [2,2,0,1]
;            result = inds[0] + inds[1]*pDims[0] + inds[2]*pDims[1] + inds[3]*pDims[2]
;            result = 48*1 + 16*0 + 4*2 + 2
;            result = 58
;
;   This needs to be done for every index. Thus, for a range of indices, such as::
;     IDL> help, arr[0:2, [1,2], 0, 0:1]
;         <Expression>    INT       = Array[3, 2, 1, 2]
;
;   All three indices in the first dimension must be added to the two indices of the
;   second dimension. Thus, when computing the indices of the second dimension, two
;   3x2 arrays must be formed (via Rebin), then added together, resulting in a six-
;   element array::
;
;     IDL> ind0 = [0,1,2]
;     IDL> ind1 = [1,2]
;     IDL> ind0 = rebin(ind0, 3, 2)
;     IDL> ind1 = rebin(transpose(ind1), 3, 2) * pDim[0]
;     IDL> print, ind0
;             0    1    2
;             0    1    2
;     IDL> print, ind1
;             4    4    4
;             8    8    8
;     IDL> print, ind0 + ind1
;             4    5    6
;             8    9   10
;     IDL> print, arr[0:2, [0,1]]   <-- Check answer
;             4    5    6
;             8    9   10
;
;   Following the above procedure, two 6x1 arrays are summed, resulting in another
;   6-element matrix. Finally, two 6x2 arrays give the full 12 element array of indices.
;
;
; :Author:
;   Matthew Argall::
;       University of New Hampshire
;       Morse Hall, Room 113
;       8 College Rd.
;       Durham, NH, 03824
;       matthew.argall@wildcats.unh.edu
;
; :History:
;	Modification History::
;       2013/03/02  -   Written by Matthew Argall.
;       2014/04/03  -   Indices are generated from low to high to make routine more
;                           transparent. Detailed example included. Incorporated the
;                           method provided by Chris Torrence of Excelis VIS. - MRA
;-
;*****************************************************************************************
;+
;   The purpose of this function is to convert a range of subscripts to an array
;   of subscripts.
;
; :Params:
;       DIM:                in, required, type=lonarr
;                           Size of each dimension of the original array.
;       ISRANGE:            in, required, type=intarr
;                           A vector that has one element for each Subscript argument
;                               supplied by the user; each element contains a zero if the
;                               corresponding input argument was a scalar index value or
;                               array of indices, or a one if the corresponding input
;                               argument was a subscript range.
;       SUBSCRIPT:          in, required, type=integer/intarr(3)
;                           Index subscripts. Either a scalar, an index array, or a 
;                               subscript range in the form [start, stop, step_size]
;
; :Keywords:
;       COUNT:              out, optional, type=long
;                           The number of indices.
;
; :Returns:
;       RESULT:             Index array spanned by SUBSCRIPT.
;-
function MrReformIndices_Subscripts, dim, isRange, subscript, $
COUNT=nInds
    compile_opt strictarr

    ;Specific indices were given?
    if isRange eq 0 then begin
        result = subscript
        nInds = n_elements(subscript)
    
    ;Range of indices
    endif else begin
        ;Convert to positive indices
        sub = subscript
        if sub[0] lt 0 then sub[0] += dim
        if sub[1] lt 0 then sub[1] += dim
        
        ;Create the array of indices
        nInds = ((sub[1] - sub[0] + 1) / sub[2]) > 1
        result = sub[0] + sub[2]*lindgen(nInds)
    endelse
    
    return, result
end


;+
;   This method was provided by Chris Torrence from Excelis VIS via the `IDL news group.
;       <https://groups.google.com/forum/#!searchin/comp.lang.idl-pvwave/IDL_Object$20$2F$2F$20help$20with/comp.lang.idl-pvwave/H86KPPit46k/-jBdqFkWs4gJ>`
;
;   This is intended for the IDL_Object::_OverloadBracketsLeftSide method. Normally,
;   the `DIM` parameter is not required. See below.
;-
function MrReformIndices_Excelis, dim, isRange, i1, i2, i3, i4, i5, i6, i7, i8
    compile_opt strictarr
    on_error, 2
    
    nSubscripts = n_elements(isRange)
    
    ;Compute the number of subelements for each indexing dimension.
    ;   - The number of elements in a particular dimensions of VALUE
    dimSubArr = LON64ARR(nSubscripts) 

    ;Adjust for negative indices or "*" indices.
    ;   - "*" results in a subscript value of [0, -1, 1].
    ;   - If the subscript was given && it is a subscript range,
    ;     turn negative indices positive by adding the total number of elements in
    ;     that dimension
    if (nSubscripts eq 8 && isRange[7]) then begin
        if (i8[0] lt 0) then i8[0] += dims[7]
        if (i8[1] lt 0) then i8[1] += dims[7]
    endif
    if (nSubscripts ge 7 && isRange[6]) then begin
        if (i7[0] lt 0) then i7[0] += dims[6]
        if (i7[1] lt 0) then i7[1] += dims[6]
    endif
    if (nSubscripts ge 6 && isRange[5]) then begin
        if (i6[0] lt 0) then i6[0] += dims[5]
        if (i6[1] lt 0) then i6[1] += dims[5]
    endif
    if (nSubscripts ge 5 && isRange[4]) then begin
        if (i5[0] lt 0) then i5[0] += dims[4]
        if (i5[1] lt 0) then i5[1] += dims[4]
    endif
    if (nSubscripts ge 4 && isRange[3]) then begin
        if (i4[0] lt 0) then i4[0] += dims[3]
        if (i4[1] lt 0) then i4[1] += dims[3]
    endif
    if (nSubscripts ge 3 && isRange[2]) then begin
        if (i3[0] lt 0) then i3[0] += dims[2]
        if (i3[1] lt 0) then i3[1] += dims[2]
    endif
    if (nSubscripts ge 2 && isRange[1]) then begin
        if (i2[0] lt 0) then i2[0] += dims[1]
        if (i2[1] lt 0) then i2[1] += dims[1]
    endif
    if (nSubscripts ge 1 && isRange[0]) then begin
        if (i1[0] lt 0) then i1[0] += dims[0]
        if (i1[1] lt 0) then i1[1] += dims[0]
    endif

    ;Number of elements in each dimension of the requested subarray.
    switch (nSubscripts) of
        8: dimSubArr[7] = isRange[7] ? (i8[1] - i8[0])/i8[2] + 1 : n_elements(i8)
        7: dimSubArr[6] = isRange[6] ? (i7[1] - i7[0])/i7[2] + 1 : n_elements(i7)
        6: dimSubArr[5] = isRange[5] ? (i6[1] - i6[0])/i6[2] + 1 : n_elements(i6)
        5: dimSubArr[4] = isRange[4] ? (i5[1] - i5[0])/i5[2] + 1 : n_elements(i5)
        4: dimSubArr[3] = isRange[3] ? (i4[1] - i4[0])/i4[2] + 1 : n_elements(i4)
        3: dimSubArr[2] = isRange[2] ? (i3[1] - i3[0])/i3[2] + 1 : n_elements(i3)
        2: dimSubArr[1] = isRange[1] ? (i2[1] - i2[0])/i2[2] + 1 : n_elements(i2)
        1: dimSubArr[0] = isRange[0] ? (i1[1] - i1[0])/i1[2] + 1 : n_elements(i1)
    endswitch 

    ;Compute the cumulative and total number of elements. 
    ncum    = product(dimSubArr, /INTEGER, /CUMULATIVE) 
    n       = product(dimSubArr, /INTEGER) 
    indices = n eq 1 ? 0LL : lon64arr(n) 

    ;Product of all "previous" dimensions
    ;   - number of elements preceeding the "current" dimension)
    pdim = product(dims, /CUMULATIVE, /INTEGER) 

    ;Construct the indices for the first dimension.
    ;   - We already know that there are more than one dimensions.
    ;   - All indices need to be appended to the indices already generated 
    ix = isRange[0] ? i1[0] + i1[2]*l64indgen(dimSubArr[0]) : i1
    if ((dimSubArr[0] ne n) && isa(ix, /ARRAY)) then ix = rebin(ix, dimSubArr[0], n/dimSubArr[0])
    indices += ix

    ;Construct the indices for the higher dimensions.
    for i=1, nSubscripts-1 do begin
        ;Get the raw indices for this particular dimension.
        case (i) of
            1: ix = (isRange[1] ? i2[0] + i2[2]*l64indgen(dimSubArr[i]) : i2)
            2: ix = (isRange[2] ? i3[0] + i3[2]*l64indgen(dimSubArr[i]) : i3)
            3: ix = (isRange[3] ? i4[0] + i4[2]*l64indgen(dimSubArr[i]) : i4)
            4: ix = (isRange[4] ? i5[0] + i5[2]*l64indgen(dimSubArr[i]) : i5)
            5: ix = (isRange[5] ? i6[0] + i6[2]*l64indgen(dimSubArr[i]) : i6)
            6: ix = (isRange[6] ? i7[0] + i7[2]*l64indgen(dimSubArr[i]) : i7)
            7: ix = (isRange[7] ? i8[0] + i8[2]*l64indgen(dimSubArr[i]) : i8)
        endcase
        
        ;Multiply indices for this dimension by all the lower
        ;dimensions since this dimension spans them.
        ix *= pdim[i-1]
        ix = reform(ix, 1, nd[i], /OVERWRITE)
        
        ;Use rebin to replicate the indices - make them "repeat" for all of
        ;the lower dimensions, and "duplicate" them for the higher dims.
        if valDims[i] ne n then ix = rebin(ix, ncum[i-1], dimSubArr[i], n/ncum[i])
        indices += ix 
    endfor 

    return, indices
end



;+
;
; :Params:
;       DIMS:               in, required, type=lonarr
;                           Size of each dimension of the original array.
;       DIMENSIONS:         out, optional, type=lon64arr
;                           A named variable into which the dimension sizes of the
;                               desired subarray will be returned.
;       ISRANGE:            in, required, type=intarr
;                           A vector that has one element for each Subscript argument
;                               supplied by the user; each element contains a zero if the
;                               corresponding input argument was a scalar index value or
;                               array of indices, or a one if the corresponding input
;                               argument was a subscript range.
;       SUBSCRIPT1:         in, required, type=integer/intarr(3)
;                           Index subscripts. Either a scalar, an index array, or a 
;                               subscript range in the form [start, stop, step_size]
;       SUBSCRIPT2:         in, optional, type=integer/intarr(3)
;                           Index subscripts.
;       SUBSCRIPT3:         in, optional, type=integer/intarr(3)
;                           Index subscripts.
;       SUBSCRIPT4:         in, optional, type=integer/intarr(3)
;                           Index subscripts.
;       SUBSCRIPT5:         in, optional, type=integer/intarr(3)
;                           Index subscripts.
;       SUBSCRIPT6:         in, optional, type=integer/intarr(3)
;                           Index subscripts.
;       SUBSCRIPT7:         in, optional, type=integer/intarr(3)
;                           Index subscripts.
;       SUBSCRIPT8:         in, optional, type=integer/intarr(3)
;                           Index subscripts.
;
; :Keywords:
;       COUNT:              out, optional, type=long
;                           The number of indices.
;
; :Returns:
;       RESULT:             Array of 1-Dimensional subscripts corresponding to the input
;                               subscript ranges.
;-
function MrReformIndices, dims, isRange, subscript1, subscript2, subscript3, subscript4, $
                                         subscript5, subscript6, subscript7, subscript8, $
DIMENSIONS=dimensions, $
COUNT=count, $
IDL_METHOD=idl_method, $
SORT=sort
    compile_opt strictarr
    on_error, 2
    
    ;Use the method proviced by Excelis VIS?
    if keyword_set(idl_method) then begin
        indices = MrReformIndices_Excelis(dims, isRange, subscript1, subscript2, $
                                          subscript3, subscript4, subscript5, subscript6, $
                                          subscript7, subscript8)
        return, indices
    endif

    ;Number of subscripts given
    nSubs = n_elements(isRange)

    ;First indicex of each dimension
    pDims = product(dims, /CUMULATIVE, /INTEGER)
    
    ;Dimensions of requested subarray
    dimensions = lon64arr(nSubs)
    
    ;Get the inices of the first dimension
    ;   - If only one subscript was given, it has access to the entire array.
    if nSubs eq 1 $
        then indices = MrReformIndices_Subscripts(total(pDims), isRange[0], subscript1, COUNT=count) $
        else indices = MrReformIndices_Subscripts(dims[0], isRange[0], subscript1, COUNT=count)
    
    ;Transpose and Rebin do not like scalars
    if count eq 1 then indices = [indices]
    dimensions[0] = count
    
    ;Step through all higher dimensions
    for i = 1, nSubs-1 do begin
    
        ;Convert subscript ranges to arrays of indices.
        case i of
            7: tempInds = MrReformIndices_Subscripts(dims[i], isRange[i], subscript8, COUNT=n)
            6: tempInds = MrReformIndices_Subscripts(dims[i], isRange[i], subscript7, COUNT=n)
            5: tempInds = MrReformIndices_Subscripts(dims[i], isRange[i], subscript6, COUNT=n)
            4: tempInds = MrReformIndices_Subscripts(dims[i], isRange[i], subscript5, COUNT=n)
            3: tempInds = MrReformIndices_Subscripts(dims[i], isRange[i], subscript4, COUNT=n)
            2: tempInds = MrReformIndices_Subscripts(dims[i], isRange[i], subscript3, COUNT=n)
            1: tempInds = MrReformIndices_Subscripts(dims[i], isRange[i], subscript2, COUNT=n)
            0: tempInds = MrReformIndices_Subscripts(dims[i], isRange[i], subscript1, COUNT=n)
        endcase
        
        ;Rebin and transpose like arrays
        if n eq 1 then tempInds = [tempInds]
        dimensions[i] = n
        
        ;Multiply by the number of elements in the previous dimension
        tempInds *= pDims[i-1]
        
        ;Add them to the previous result
        indices  = rebin(indices, count, n) + rebin(transpose(temporary(tempInds)), count, n)
        count   *= n
        
        ;Make a single dimension
        indices = reform(indices, count, /OVERWRITE)
    endfor
    
    ;Sort the indices into ascending order?
    if keyword_set(sort) then indices = indices[sort(indices)]
    
    ;Return scalars?
    if count eq 1 then begin
        indices = indices[0]
        dimensions = dimensions[0]
    endif
     
    return, indices
end

    
;---------------------------------------------------------------------
;Main-Level Program (IDL> .r MrReformIndices) ////////////////////////
;---------------------------------------------------------------------

;EXAMPLE 1
;   Create a multi-dimensional array and access it with the 3 types of indexing styles
;       1. Scalar
;       2. Array
;       3. Range, Interval
array   = indgen(2,4,4,2)
dims    = size(array, /DIMENSIONS)
indices = MrReformIndices(dims, [0,0,1,0], 0, [0,2], [1,3,1], 1, COUNT=n)

print, '--------------------------------------------------------'
help, array
print, 'array[0, [0, 2], 1:3, 1]  = [' + strjoin(strtrim(reform(array[0, [0, 2], 1:3, 1], n), 2), ', ') + ']'
print, 'array[indices]            = [' + strjoin(strtrim(array[indices], 2), ', ') + ']'
print, ''

;EXAMPLE 2
;   1D array access via a vector of indices.
array = indgen(6)
dims = size(array, /DIMENSIONS)
indices = MrReformIndices(dims, 0, [0,3,5], COUNT=n)

print, '--------------------------------------------------------'
help, array
print, 'array[[0,3,5]]            = [' + strjoin(strtrim(reform(array[[0,3,5]], n), 2), ', ') + ']'
print, 'array[indices]            = [' + strjoin(strtrim(array[indices], 2), ', ') + ']'
print, ''

;EXAMPLE 3
;   Reform a subarray of a multi-dimensional array.
array   = indgen(2,4,4,2)
dims    = size(array, /DIMENSIONS)
indices = MrReformIndices(dims, [0,0,1,0], 0, [0,2], [1,3,1], 1, COUNT=n, DIMENSION=dimensions)

print, '--------------------------------------------------------'
help, array[0, [0,2], 1:3, 1]
help, array[indices]
help, reform(array[indices], dimensions)
print, ''

;EXAMPLE 3
;   Access a multi-dimensional array with a vector of indices.
array   = indgen(2,4,4,2)
dims    = size(array, /DIMENSIONS)
indices = MrReformIndices(dims, 0, [5,7,20,48,63], COUNT=n, DIMENSION=dimensions)

print, '--------------------------------------------------------'
help, array
print, 'array[[5,7,20,48,63]]     = [' + strjoin(strtrim(array[[5,7,20,48,63]], 2), ', ') + ']'
print, 'array[indices]            = [' + strjoin(strtrim(array[indices], 2), ', ') + ']'
print, ''
end

